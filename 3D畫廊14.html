<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>創意3D畫廊</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.0/marked.min.js"></script> 
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#FF7D00',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .perspective-1000 {
                perspective: 1000px;
            }
            .preserve-3d {
                transform-style: preserve-3d;
            }
            .backface-hidden {
                backface-visibility: hidden;
            }
            .rotate-y-0 {
                transform: rotateY(0deg);
            }
            .rotate-y-45 {
                transform: rotateY(45deg);
            }
            .rotate-y-90 {
                transform: rotateY(90deg);
            }
            .rotate-y-135 {
                transform: rotateY(135deg);
            }
            .rotate-y-180 {
                transform: rotateY(180deg);
            }
            .rotate-y-225 {
                transform: rotateY(225deg);
            }
            .rotate-y-270 {
                transform: rotateY(270deg);
            }
            .rotate-y-315 {
                transform: rotateY(315deg);
            }
            .transition-transform-slow {
                transition: transform 1s ease-out;
            }
            .category-active {
                background-color: rgba(22, 93, 255, 0.9);
                color: white;
                transform: translateY(-5px);
                box-shadow: 0 5px 15px rgba(22, 93, 255, 0.3);
            }
        }
    </style>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
            background: linear-gradient(135deg, #1E293B 0%, #0F172A 100%);
            min-height: 100vh;
            color: #F8FAFC;
        }
        
        .gallery-container {
            position: relative;
            width: 100%;
            height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .carousel {
            position: relative;
            width: 250px;
            height: 350px;
            transform-style: preserve-3d;
            transition: transform 1s ease;
        }
        
        .carousel-item {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s ease, box-shadow 0.5s ease;
            cursor: pointer; /* Add pointer to indicate interactivity */
        }
        
        .carousel-item:hover {
            box-shadow: 0 0 30px rgba(22, 93, 255, 0.7);
            transform: translateZ(20px);
        }
        
        .carousel-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s ease;
        }
        
        .carousel-item:hover img {
            transform: scale(1.05);
        }
        
        .carousel-item:nth-child(1) { transform: rotateY(0deg) translateZ(320px); }
        .carousel-item:nth-child(2) { transform: rotateY(45deg) translateZ(320px); }
        .carousel-item:nth-child(3) { transform: rotateY(90deg) translateZ(320px); }
        .carousel-item:nth-child(4) { transform: rotateY(135deg) translateZ(320px); }
        .carousel-item:nth-child(5) { transform: rotateY(180deg) translateZ(320px); }
        .carousel-item:nth-child(6) { transform: rotateY(225deg) translateZ(320px); }
        .carousel-item:nth-child(7) { transform: rotateY(270deg) translateZ(320px); }
        .carousel-item:nth-child(8) { transform: rotateY(315deg) translateZ(320px); }
        
        .nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(22, 93, 255, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        .nav-btn:hover {
            background: rgba(22, 93, 255, 1);
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 0 15px rgba(22, 93, 255, 0.7);
        }
        
        .nav-btn.prev {
            left: 10%;
        }
        
        .nav-btn.next {
            right: 10%;
        }
        
        .gallery-indicators {
            display: flex;
            justify-content: center;
            margin-top: 30px;
            gap: 10px;
        }
        
        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(248, 250, 252, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .indicator.active {
            background: rgba(22, 93, 255, 1);
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(22, 93, 255, 0.7);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .animate-fade-in {
            animation: fadeIn 0.8s ease forwards;
        }
        
        .gallery-info {
            max-width: 800px;
            margin: 30px auto;
            text-align: center;
            padding: 0 20px;
        }
        
        .gallery-title {
            font-size: clamp(1.5rem, 3vw, 2.5rem);
            font-weight: 700;
            margin-bottom: 15px;
            color: #F8FAFC;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .gallery-desc {
            font-size: clamp(1rem, 1.5vw, 1.2rem);
            color: rgba(248, 250, 252, 0.8);
            line-height: 1.6;
        }
        
        /* Category navigation style */
        .category-nav {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 30px auto;
            max-width: 900px;
            padding: 0 20px;
        }
        
        .category-btn {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(248, 250, 252, 0.9);
            border: none;
            border-radius: 25px;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .category-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .category-btn i {
            font-size: 1.2rem;
        }
        
        /* Loading animation style */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30, 41, 59, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(22, 93, 255, 0.3);
            border-radius: 50%;
            border-top-color: rgba(22, 93, 255, 1);
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Modal style */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: flex-start; /* Align content to the left */
            align-items: flex-start; /* Align content to the top */
            z-index: 30;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: #1E293B;
            padding: 30px;
            border-radius: 10px;
            max-width: 380px; /* Set to a narrower width for vertical layout */
            width: calc(100% - 10vw); /* Responsive width adjustment, considering left/right margins */
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            position: relative; /* Maintain relative positioning */
            margin-top: 50px; /* Push down from the top */
            margin-left: 5vw; /* Push from the left */
            transform: translateY(20px); /* Initial animation state */
            transition: transform 0.3s ease, opacity 0.3s ease; /* Transition effect */
            opacity: 0; /* Initial animation state */
            text-align: left; /* Align content text to the left */
        }

        .modal.active .modal-content {
            transform: translateY(0); /* Final animation state */
            opacity: 1; /* Final animation state */
        }

        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #F8FAFC;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .modal-close-btn:hover {
            color: #FF7D00;
        }

        .modal-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: #F8FAFC;
            text-align: left; /* Align title text to the left */
        }

        .modal-story {
            font-size: 1rem;
            color: rgba(248, 250, 252, 0.8);
            line-height: 1.7;
            white-space: pre-wrap; /* Preserve line breaks */
            max-height: 300px; /* Limit height for long stories */
            overflow-y: auto; /* Add scrollbar if content exceeds height */
        }
        
        /* API Key input section style */
        .api-key-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .api-key-section input {
            flex-grow: 1;
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid rgba(248, 250, 252, 0.3);
            background: rgba(0, 0, 0, 0.2);
            color: #F8FAFC;
            font-size: 0.9rem;
            max-width: 400px;
        }

        .api-key-section input::placeholder {
            color: rgba(248, 250, 252, 0.6);
        }

        .api-key-section button {
            padding: 10px 20px;
            border-radius: 5px;
            background: #165DFF;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .api-key-section button:hover {
            background: #0D4EDF;
        }

        .api-key-section #clearApiKeyBtn { /* Added style for the new button */
            background: #FF7D00;
        }

        .api-key-section #clearApiKeyBtn:hover { /* Added hover style for the new button */
            background: #E06C00;
        }

        /* New modal tab style */
        .modal-section {
            display: none; /* Hidden by default */
        }

        .modal-section.active {
            display: block; /* Display when active */
        }

        .modal-subtitle {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: #F8FAFC;
            text-align: left; /* Align subtitle text to the left */
        }

        /* Disabled state for tab buttons */
        .modal-tab-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #4A5568 !important; /* Override hover effect */
        }

        /* Custom image album modal style */
        #customAlbumModal .modal-content {
            max-width: 500px; /* Adjust width for URL input */
            margin-left: auto; /* Center it for input */
            margin-right: auto;
            text-align: center;
        }
        /* Style for the file input */
        #customAlbumFileInput {
            display: block; /* Make it a block element */
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(248, 250, 252, 0.3);
            background: rgba(0, 0, 0, 0.2);
            color: #F8FAFC;
            font-size: 0.9rem;
            margin-bottom: 15px; /* Add some space below */
        }
        #customAlbumFileInput::-webkit-file-upload-button {
            background: #165DFF;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        #customAlbumFileInput::-webkit-file-upload-button:hover {
            background: #0D4EDF;
        }

        #customAlbumModal button {
            margin-top: 15px;
            padding: 10px 25px;
            border-radius: 5px;
            background: #165DFF;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        #customAlbumModal button:hover {
            background: #0D4EDF;
        }

        /* Load more button style */
        #loadMoreBtn {
            display: none; /* Hidden by default */
            margin: 20px auto;
            padding: 12px 25px;
            border-radius: 25px;
            background: #FF7D00;
            color: white;
            border: none;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(255, 125, 0, 0.3);
        }
        #loadMoreBtn:hover {
            background: #E06C00;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 125, 0, 0.5);
        }

        /* Speech control button style */
        .speech-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: flex-start; /* Align buttons to the left */
        }

        .speech-btn {
            padding: 8px 15px;
            border-radius: 5px;
            background: #28A745; /* Green for play */
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .speech-btn:hover {
            background: #218838;
        }

        .speech-btn.stop {
            background: #DC3545; /* Red for stop */
        }

        .speech-btn.stop:hover {
            background: #C82333;
        }

        .speech-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #6C757D !important; /* Grey when disabled */
        }

        /* Pokemon Gallery Styles */
        #pokemonGallerySection {
            display: none; /* Hidden by default */
            margin-top: 40px;
            text-align: center;
        }

        #pokemonSearchInput {
            width: 100%;
            max-width: 400px;
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(248, 250, 252, 0.3);
            background: rgba(0, 0, 0, 0.2);
            color: #F8FAFC;
            font-size: 1rem;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        #pokemonSearchInput::placeholder {
            color: rgba(248, 250, 252, 0.6);
        }

        #pokemonGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
        }

        .pokemon-card {
            background: #2D3748;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            text-align: center;
        }

        .pokemon-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 8px 25px rgba(22, 93, 255, 0.5);
        }

        .pokemon-card img {
            width: 120px;
            height: 120px;
            object-fit: contain;
            margin-bottom: 10px;
            image-rendering: pixelated; /* For pixel art style */
        }

        .pokemon-card h5 {
            font-size: 1.2rem;
            font-weight: 600;
            color: #F8FAFC;
            margin-bottom: 5px;
            text-transform: capitalize;
        }

        .pokemon-card p {
            font-size: 0.9rem;
            color: rgba(248, 250, 252, 0.7);
            margin-bottom: 3px;
        }

        .pokemon-types {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            margin-top: 8px;
        }

        .pokemon-type-badge {
            background: #FF7D00;
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: capitalize;
        }

        /* Responsive adjustments for mobile devices */
        @media (max-width: 768px) {
            .gallery-container {
                height: 400px;
            }
            
            .carousel {
                width: 200px;
                height: 300px;
            }
            
            .carousel-item:nth-child(n) {
                transform: rotateY(calc(var(--i) * 45deg)) translateZ(260px);
            }
            
            .nav-btn {
                width: 40px;
                height: 40px;
            }
            
            .nav-btn.prev {
                left: 5%;
            }
            
            .nav-btn.next {
                right: 5%;
            }
            
            .category-nav {
                gap: 10px;
                padding: 0 10px;
            }
            
            .category-btn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .category-btn i {
                font-size: 1rem;
            }

            .api-key-section {
                flex-direction: column;
                align-items: stretch;
            }

            .modal-content {
                margin-left: 2.5vw; /* Adjust for smaller screens */
                margin-right: 2.5vw;
                width: 95%; /* Take more width on smaller screens */
            }
            #customAlbumModal .modal-content {
                width: calc(100% - 5vw); /* Adjust for custom album modal on mobile */
            }

            #pokemonGrid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <header class="py-6 px-4 md:px-8">
        <div class="max-w-7xl mx-auto">
            <h1 class="text-[clamp(1.8rem,4vw,3rem)] font-bold text-center text-white drop-shadow-lg">創意3D畫廊</h1>
            <p class="text-center text-gray-300 mt-2 max-w-2xl mx-auto">探索這個使用CSS 3D變換創建的沉浸式畫廊，體驗獨特的3D視覺效果</p>
            
            <div class="api-key-section max-w-2xl mx-auto">
                <input type="text" id="geminiApiKeyInput" placeholder="在此輸入您的 Gemini API 金鑰">
                <button id="saveApiKeyBtn">設定 API 金鑰</button>
                <button id="clearApiKeyBtn">API 金鑰消除</button>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-12">
        <div class="category-nav animate-fade-in" style="animation-delay: 0.3s">
            <button class="category-btn category-active" data-category="nature">
                <i class="fa-solid fa-tree"></i> 自然風光
            </button>
            <button class="category-btn" data-category="architecture">
                <i class="fa-solid fa-building"></i> 建築設計
            </button>
            <button class="category-btn" data-category="people">
                <i class="fa-solid fa-users"></i> 人物肖像
            </button>
            <button class="category-btn" data-category="animals">
                <i class="fa-solid fa-paw"></i> 動物世界
            </button>
            <button class="category-btn" data-category="abstract">
                <i class="fa-solid fa-circle-half-stroke"></i> 抽象藝術
            </button>
            <button class="category-btn" data-category="food">
                <i class="fa-solid fa-utensils"></i> 美食攝影
            </button>
            <button class="category-btn" data-category="city">
                <i class="fa-solid fa-city"></i> 城市景觀
            </button>
            <button class="category-btn" data-category="travel">
                <i class="fa-solid fa-plane"></i> 旅行紀實
            </button>
            <button class="category-btn" data-category="night">
                <i class="fa-solid fa-moon"></i> 夜景攝影
            </button>
            <button class="category-btn" data-category="macro">
                <i class="fa-solid fa-magnifying-glass-plus"></i> 微距攝影
            </button>
            <button class="category-btn" data-category="custom_album">
                <i class="fa-solid fa-folder-open"></i> 自訂圖片集
            </button>
            <!-- Delete external image library (Picsum) button -->
            <button class="category-btn" data-category="pexels_photos"> <i class="fa-solid fa-images"></i> Pexels 圖片庫
            </button>
            <button class="category-btn" data-category="pixabay_photos"> <i class="fa-solid fa-camera-retro"></i> Pixabay 圖片庫
            </button>
            <button class="category-btn" data-category="pokemon_gallery"> <i class="fa-solid fa-hat-wizard"></i> 寶可夢圖片庫
            </button>
            <button class="category-btn" data-category="instructions"> <i class="fa-solid fa-circle-info"></i> 操作說明
            </button>
        </div>

        <div class="loading-overlay" id="loadingOverlay">
            <div class="loader"></div>
        </div>

        <div id="mainGalleryContent">
            <div class="gallery-container perspective-1000">
                <div id="carousel" class="carousel preserve-3d">
                </div>
                
                <button id="prevBtn" class="nav-btn prev animate-fade-in" style="animation-delay: 0.2s">
                    <i class="fa-solid fa-chevron-left"></i>
                </button>
                <button id="nextBtn" class="nav-btn next animate-fade-in" style="animation-delay: 0.4s">
                    <i class="fa-solid fa-chevron-right"></i>
                </button>
            </div>
            
            <div class="gallery-indicators" id="indicators">
            </div>
        </div>
        
        <button id="loadMoreBtn" class="hidden">載入更多</button>

        <!-- New section for Pokemon Gallery -->
        <div id="pokemonGallerySection">
            <input type="text" id="pokemonSearchInput" placeholder="搜尋寶可夢名稱...">
            <div id="pokemonGrid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 mt-4">
                <!-- Pokemon cards will be loaded here -->
            </div>
        </div>
        <!-- End of Pokemon Gallery Section -->

        <div class="gallery-info animate-fade-in" style="animation-delay: 1.5s">
            <h2 class="gallery-title" id="categoryTitle">自然風光</h2>
            <p class="gallery-desc" id="categoryDesc">
                欣賞大自然的壯麗景色，包括山脈、森林、湖泊、海洋等令人驚嘆的自然景觀。每張照片都捕捉到了大自然的美麗瞬間。
            </p>
        </div>
    </main>

    <footer class="py-8 bg-dark/50 mt-12">
        <div class="max-w-7xl mx-auto px-4 text-center text-gray-400">
            <p>© 2025 創意3D畫廊 | 使用HTML、CSS和JavaScript構建</p>
            <div class="mt-4 flex justify-center gap-4">
                <a href="#" class="text-gray-400 hover:text-primary transition-colors">
                    <i class="fa-brands fa-github"></i>
                </a>
                <a href="#" class="text-gray-400 hover:text-primary transition-colors">
                    <i class="fa-brands fa-twitter"></i>
                </a>
                <a href="#" class="text-gray-400 hover:text-primary transition-colors">
                    <i class="fa-brands fa-instagram"></i>
                </a>
            </div>
        </div>
    </footer>

    <div id="storyModal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" id="closeModalBtn">&times;</button>
            <h3 class="modal-title" id="modalMainTitle">圖片故事與問答</h3>
            
            <div id="modalTabsContainer" class="flex justify-start gap-4 mb-4">
                <button id="storyTabBtn" class="px-4 py-2 rounded-md bg-primary hover:bg-blue-700 text-white transition-colors modal-tab-btn">圖片故事</button>
                <button id="qaTabBtn" class="px-4 py-2 rounded-md bg-gray-600 hover:bg-gray-700 text-white transition-colors modal-tab-btn">圖片問答</button>
            </div>

            <div id="storyContentArea" class="modal-section active">
                <h4 class="modal-subtitle" id="modalStoryTitle"></h4>
                <p class="modal-story" id="modalStoryContent"></p>
                <div class="speech-controls">
                    <button id="playStoryBtn" class="speech-btn" disabled><i class="fa-solid fa-play"></i> 播放語音</button>
                    <button id="stopStoryBtn" class="speech-btn stop" disabled><i class="fa-solid fa-stop"></i> 停止語音</button>
                </div>
                <div id="modalLoadingStory" class="loader mx-auto mt-4" style="display: none;"></div>
            </div>

            <div id="qaContentArea" class="modal-section">
                <h4 class="modal-subtitle mb-2">針對圖片提問：</h4>
                <textarea id="questionInput" class="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary mb-3" rows="3" placeholder="請輸入您的問題..."></textarea>
                <button id="askQuestionBtn" class="w-full p-2 rounded-md bg-primary hover:bg-blue-700 text-white transition-colors">提問</button>
                <div class="speech-controls">
                    <button id="playQaBtn" class="speech-btn" disabled><i class="fa-solid fa-play"></i> 播放語音</button>
                    <button id="stopQaBtn" class="speech-btn stop" disabled><i class="fa-solid fa-stop"></i> 停止語音</button>
                </div>
                <div id="qaLoading" class="loader mx-auto mt-4" style="display: none;"></div>
                <div id="answerOutput" class="modal-story mt-4 border-t border-gray-700 pt-4"></div>
            </div>
        </div>
    </div>

    <div id="customAlbumModal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" id="closeCustomAlbumModalBtn">&times;</button>
            <h3 class="modal-title">載入自訂圖片集</h3>
            <p class="text-gray-300 mb-4">請點擊下方按鈕選擇一個資料夾，程式將從中載入圖片。</p>
            <input type="file" id="customAlbumFileInput" webkitdirectory directory multiple accept="image/*">
            <button id="triggerCustomAlbumLoadBtn" style="display: none;">選擇資料夾</button> 
        </div>
    </div>

    <script type="module">
        // Import GoogleGenerativeAI library
        import { GoogleGenerativeAI } from 'https://esm.run/@google/generative-ai';

        // Global state variables for controlling carousel and modal states.
        let isCarouselRunning = true; // True if the carousel is actively rotating
        let isModalOpen = false;      // True if any modal (story/QA or custom album or information message) is currently open

        document.addEventListener('DOMContentLoaded', () => {
            // User-provided Gemini API key
            let userGeminiApiKey = localStorage.getItem('geminiApiKey') || ""; // Load from localStorage (if available)

            // Get API key input elements
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
            const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
            const clearApiKeyBtn = document.getElementById('clearApiKeyBtn'); 

            // Set initial value of the input field
            geminiApiKeyInput.value = userGeminiApiKey;
            // If there's a key, display it as password by default
            if (userGeminiApiKey) {
                geminiApiKeyInput.type = "password";
            }

            // When input field gains focus, change its type to text
            geminiApiKeyInput.addEventListener('focus', () => {
                geminiApiKeyInput.type = "text";
            });

            // When input field loses focus and has content, change its type back to password
            geminiApiKeyInput.addEventListener('blur', () => {
                if (geminiApiKeyInput.value.trim() !== '') {
                    geminiApiKeyInput.type = "password";
                }
            });

            // Modal elements and QA related elements
            const storyModal = document.getElementById('storyModal');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const modalMainTitle = document.getElementById('modalMainTitle'); // Reference to the main modal title
            const modalStoryTitle = document.getElementById('modalStoryTitle');
            const modalStoryContent = document.getElementById('modalStoryContent');
            const modalLoadingStory = document.getElementById('modalLoadingStory');
            const storyTabBtn = document.getElementById('storyTabBtn');
            const qaTabBtn = document.getElementById('qaTabBtn');
            const modalTabsContainer = document.getElementById('modalTabsContainer'); // New reference for tabs container
            const storyContentArea = document.getElementById('storyContentArea');
            const qaContentArea = document.getElementById('qaContentArea');
            const questionInput = document.getElementById('questionInput');
            const askQuestionBtn = document.getElementById('askQuestionBtn');
            const answerOutput = document.getElementById('answerOutput');
            const qaLoading = document.getElementById('qaLoading');

            // Speech Synthesis elements
            const playStoryBtn = document.getElementById('playStoryBtn');
            const stopStoryBtn = document.getElementById('stopStoryBtn');
            const playQaBtn = document.getElementById('playQaBtn');
            const stopQaBtn = document.getElementById('stopQaBtn');

            // Custom Album Modal elements
            const customAlbumModal = document.getElementById('customAlbumModal');
            const closeCustomAlbumModalBtn = document.getElementById('closeCustomAlbumModalBtn');
            const customAlbumFileInput = document.getElementById('customAlbumFileInput'); // Changed from textarea
            const triggerCustomAlbumLoadBtn = document.getElementById('triggerCustomAlbumLoadBtn'); // This button is now hidden, file input handles it
            const loadMoreBtn = document.getElementById('loadMoreBtn');

            // Custom Album Data
            let customAlbumFiles = []; // Stores File objects from local selection
            let customAlbumCurrentIndex = 0;
            const imagesPerLoad = 8; // Number of images to load at a time

            // Pexels Photos Data
            let pexelsPage = 1; // Current page for Pexels Photos API
            // Pexels API Key
            const PEXELS_API_KEY = 'a2KqrmtTjdy9mOsjzr9fRT4VsnJSN05ZMAyRdpl5FAobVsJXCHPZlGYD'; 

            // Pixabay Photos Data
            let pixabayPage = 1; // Current page for Pixabay Photos API
            // Pixabay API Key (provided by user)
            const PIXABAY_API_KEY = '50793363-f31895e6fdc87c4f4ed175bcc'; 

            // Pokemon Gallery elements
            const mainGalleryContent = document.getElementById('mainGalleryContent');
            const pokemonGallerySection = document.getElementById('pokemonGallerySection');
            const pokemonSearchInput = document.getElementById('pokemonSearchInput');
            const pokemonGrid = document.getElementById('pokemonGrid');
            let allPokemonData = []; // Stores all fetched Pokemon data for filtering
            let displayedPokemon = []; // Stores currently displayed Pokemon (after search/pagination)
            let pokemonOffset = 0;
            const pokemonLimit = 20; // Number of Pokemon to load per request

            // Speech Synthesis state
            let currentSpeechUtterance = null;
            let isSpeaking = false;

            // Define the full instructions markdown as a string in JavaScript
            const fullInstructionsMarkdown = `## 創意3D畫廊操作說明

歡迎使用創意3D畫廊！這個應用程式讓您可以瀏覽不同類型的圖片，並利用 Gemini AI 為圖片生成故事或進行問答。以下是詳細的操作步驟：

### 一、API 金鑰設定

為了啟用圖片故事和問答功能，您需要設定 Gemini API 金鑰。此外，Pexels 圖片庫功能也需要 Pexels API 金鑰。

1. **設定 Gemini API 金鑰：**

   * 在頁面頂部的「在此輸入您的 Gemini API 金鑰」輸入框中，貼上您的 Gemini API 金鑰。

   * 點擊「設定 API 金鑰」按鈕。

   * 系統會彈出一個提示框，告知您金鑰已成功儲存。

   * 如果您想移除金鑰，點擊「API 金鑰消除」按鈕即可。

2. **設定 Pexels API 金鑰：**

   * Pexels API 金鑰已直接寫入程式碼中。您可以在程式碼的 \`const PEXELS_API_KEY = 'a2KqrmtTjdy9mOsjzr9fRT4VsnJSN05ZMAyRdpl5FAobVsJXCHPZlGYD';\` 這一行找到並確認。

   * **重要提示**：如果您想使用自己的 Pexels API 金鑰，或遇到 Pexels 圖片載入問題，請前往 [Pexels Developers 網站](https://www.pexels.com/api/) 獲取您的金鑰，並將程式碼中的 \`'a2KqrmtTjdy9mOsjzr9fRT4VsnJSN05ZMAyRdpl5FAobVsJXCHPZlGYD'\` 替換為您的實際金鑰。

3. **設定 Pixabay API 金鑰：**

   * Pixabay API 金鑰已直接寫入程式碼中。您可以在程式碼的 \`const PIXABAY_API_KEY = '50793363-f31895e6fdc87c4f4ed175bcc';\` 這一行找到並確認。

   * **重要提示**：如果您想使用自己的 Pixabay API 金鑰，或遇到 Pixabay 圖片載入問題，請前往 [Pixabay API 網站](https://pixabay.com/api/docs/) 獲取您的金鑰，並將程式碼中的 \`'50793363-f31895e6fdc87c4f4ed175bcc'\` 替換為您的實際金鑰。

### 二、瀏覽畫廊

1. **旋轉畫廊：**

   * 您可以點擊畫廊左右兩側的 **\`<\` (上一個)** 和 **\`>\` (下一個)** 按鈕來手動旋轉圖片。

   * 您也可以直接用滑鼠拖曳圖片，或在觸控螢幕上滑動，來自由旋轉畫廊。

   * 畫廊會自動每 5 秒旋轉一次。將滑鼠移到畫廊上會暫停自動旋轉，移開後會恢復。

2. **圖片指示器：**

   * 畫廊下方有一排圓點指示器，每個圓點代表畫廊中的一張圖片。

   * 點擊任一圓點，畫廊會自動旋轉到該圓點所代表的圖片位置。

### 三、選擇圖片分類

頁面中間有一排分類按鈕，您可以點擊這些按鈕來切換不同的圖片類別：

* **自然風光**：欣賞大自然的壯麗景色。

* **建築設計**：探索世界各地的建築傑作。

* **人物肖像**：捕捉人物的獨特表情和故事。

* **動物世界**：探索地球上迷人的動物。

* **抽象藝術**：欣賞富有創意的抽象藝術作品。

* **美食攝影**：探索世界各地的美食文化。

* **城市景觀**：捕捉城市的活力與魅力。

* **旅行紀實**：體驗不同文化的獨特魅力。

* **夜景攝影**：欣賞夜幕降臨後的美景。

* **微距攝影**：探索微小世界的奇妙細節。

* **自訂圖片集**：

  * 點擊此按鈕會彈出一個模態框，您可以點擊「選擇資料夾」按鈕，從您的電腦中選擇一個包含圖片的資料夾。

  * 應用程式會載入該資料夾中的圖片，並在畫廊中顯示。

  * 每次載入 8 張圖片，如果資料夾中還有更多圖片，會出現「載入更多」按鈕。

* **Pexels 圖片庫**：

  * 從 Pexels API 隨機獲取策展圖片。

  * 每次載入 8 張圖片，點擊「載入更多」可以獲取下一批圖片。

  * **請確保您的 Pexels API 金鑰已正確設定在程式碼中，否則此功能將無法正常運作。**

* **Pixabay 圖片庫**：

  * 從 Pixabay API 隨機獲取圖片。

  * 每次載入 8 張圖片，點擊「載入更多」可以獲取下一批圖片。

  * **請確保您的 Pixabay API 金鑰已正確設定在程式碼中，否則此功能將無法正常運作。**

* **寶可夢圖片庫**：

  * 從 PokéAPI 獲取寶可夢圖片及詳細資訊。
  * 提供即時搜尋功能，並以卡片式介面呈現。
  * 每張卡片顯示寶可夢圖片、名稱、身高、體重與屬性。
  * 每次載入 ${pokemonLimit} 隻寶可夢，點擊「載入更多」可以獲取下一批。

### 四、圖片互動（故事與問答）

1. **開啟互動模態框：**

   * 點擊畫廊中的任何一張圖片，會彈出一個互動模態框。

   * 如果您的 Gemini API 金鑰未設定，模態框會提示您設定金鑰。

   * 如果金鑰已設定，模態框會自動為您點擊的圖片生成一個簡短的故事。

2. **圖片故事：**

   * 模態框預設顯示「圖片故事」分頁。

   * 您可以點擊「播放語音」按鈕來聽取故事的語音朗讀。

   * 點擊「停止語音」按鈕可以停止朗讀。

3. **圖片問答：**

   * 點擊模態框中的「圖片問答」分頁。

   * 在「請輸入您的問題...」文字框中輸入您想對圖片提出的問題。

   * 點擊「提問」按鈕，Gemini AI 將嘗試根據圖片內容回答您的問題。

   * 答案會顯示在下方的輸出區域。

   * 同樣，您可以點擊「播放語音」和「停止語音」按鈕來控制答案的語音朗讀。

### 五、載入更多圖片

對於「自訂圖片集」、「Pexels 圖片庫」、「Pixabay 圖片庫」和「寶可夢圖片庫」這四個類別，如果當前顯示的圖片數量少於總數，畫廊下方會出現一個「載入更多」按鈕。點擊此按鈕可以載入該類別的下一批圖片。

希望這些說明能幫助您更好地體驗創意3D畫廊！如果您有任何其他問題，請隨時提出。
`;

            // String to remove the Pexels API key section from the instructions.
            // This section will be removed when the instructions are displayed in the modal.
            const pexelsSectionToRemove = `2. **設定 Pexels API 金鑰：**

   * Pexels API 金鑰已直接寫入程式碼中。您可以在程式碼的 \`const PEXELS_API_KEY = 'a2KqrmtTjdy9mOsjzr9fRT4VsnJSN05ZMAyRdpl5FAobVsJXCHPZlGYD';\` 這一行找到並確認。

   * **重要提示**：如果您想使用自己的 Pexels API 金鑰，或遇到 Pexels 圖片載入問題，請前往 [Pexels Developers 網站](https://www.pexels.com/api/) 獲取您的金鑰，並將程式碼中的 \`'a2KqrmtTjdy9mOsjzr9fRT4VsnJSN05ZMAyRdpl5FAobVsJXCHPZlGYD'\` 替換為您的實際金鑰。`;

            // String to remove the Pixabay API key section from the instructions.
            // This section will be removed when the instructions are displayed in the modal.
            const pixabaySectionToRemove = `3. **設定 Pixabay API 金鑰：**

   * Pixabay API 金鑰已直接寫入程式碼中。您可以在程式碼的 \`const PIXABAY_API_KEY = '50793363-f31895e6fdc87c4f4ed175bcc';\` 這一行找到並確認。

   * **重要提示**：如果您想使用自己的 Pixabay API 金鑰，或遇到 Pixabay 圖片載入問題，請前往 [Pixabay API 網站](https://pixabay.com/api/docs/) 獲取您的金鑰，並將程式碼中的 \`'50793363-f31895e6fdc87c4f4ed175bcc'\` 替換為您的實際金鑰。`;


            // Function to enable/disable tab buttons (visual change for opacity/cursor)
            function setTabButtonsEnabled(enabled) {
                storyTabBtn.disabled = !enabled;
                qaTabBtn.disabled = !enabled;
                if (enabled) {
                    storyTabBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    qaTabBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    storyTabBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    qaTabBtn.classList.add('opacity-50', 'cursor-not-allowed');
                }
            }

            // Function to show/hide tab buttons and QA content (structural change using display property)
            function setInteractiveFeaturesVisibility(visible) {
                if (visible) {
                    modalTabsContainer.style.display = 'flex'; // Show tab buttons
                    qaContentArea.style.display = 'block';     // Show QA section
                    modalStoryTitle.style.display = 'block';   // Show story subtitle
                } else {
                    modalTabsContainer.style.display = 'none'; // Hide tab buttons
                    qaContentArea.style.display = 'none';     // Hide QA section
                    modalStoryTitle.style.display = 'none';   // Hide story subtitle
                }
            }

            // Function to update speech control button states
            function updateSpeechButtons(playEnabled, stopEnabled) {
                playStoryBtn.disabled = !playEnabled;
                stopStoryBtn.disabled = !stopEnabled;
                playQaBtn.disabled = !playEnabled;
                stopQaBtn.disabled = !stopEnabled;
            }

            // Function to speak text
            function speakText(text, lang = 'zh-TW') {
                if (!('speechSynthesis' in window)) {
                    console.warn('您的瀏覽器不支持語音合成 API。');
                    return;
                }

                stopSpeaking(); // Stop any ongoing speech before starting new one

                currentSpeechUtterance = new SpeechSynthesisUtterance(text);
                currentSpeechUtterance.lang = lang;

                currentSpeechUtterance.onstart = () => {
                    isSpeaking = true;
                    updateSpeechButtons(false, true); // Disable play, enable stop
                };
                currentSpeechUtterance.onend = () => {
                    isSpeaking = false;
                    updateSpeechButtons(true, false); // Enable play, disable stop
                    currentSpeechUtterance = null;
                };
                currentSpeechUtterance.onerror = (event) => {
                    console.error('語音合成錯誤:', event.error);
                    isSpeaking = false;
                    updateSpeechButtons(true, false); // Enable play, disable stop
                    currentSpeechUtterance = null;
                };

                speechSynthesis.speak(currentSpeechUtterance);
            }

            // Function to stop speaking
            function stopSpeaking() {
                if ('speechSynthesis' in window && speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
                isSpeaking = false;
                updateSpeechButtons(true, false); // Enable play, disable stop
                currentSpeechUtterance = null;
            }

            // Function to close any currently open modal and reset global states
            function closeAnyModal() {
                console.log("[Modal] Attempting to close any modal.");
                // Ensure all modals are hidden
                if (storyModal.classList.contains('active')) {
                    storyModal.classList.remove('active');
                }
                if (customAlbumModal.classList.contains('active')) {
                    customAlbumModal.classList.remove('active');
                }
                
                isModalOpen = false; // Reset the general modal state
                stopSpeaking(); // Stop any speech when modal closes
                
                // Attempt to resume auto-play if it was paused by a modal and should resume
                // Ensure it only resumes if current category is not pokemon_gallery
                if (currentCategory !== 'pokemon_gallery' && !isCarouselRunning) {
                    setupAutoPlay(); // Restart auto-play if it was running and paused by modal
                }
                console.log("[Modal] All modals closed. isModalOpen:", isModalOpen, "isCarouselRunning:", isCarouselRunning);
            }


            // Throttling function
            function throttle(func, limit) { // Removed warningMessage parameter
                let timeoutId = null;
                let lastArgs = null;
                let lastThis = null;
                let lastRan = 0;

                const throttled = function(...args) {
                    const context = this;
                    const now = Date.now();

                    // If a modal is open, suppress execution.
                    // This prevents events from triggering while a modal is active.
                    if (isModalOpen) {
                        console.log("Throttle suppressed: A modal is currently open.");
                        return;
                    }

                    if (now - lastRan >= limit) {
                        // If enough time has passed, execute immediately
                        lastRan = now;
                        func.apply(context, args);
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                            timeoutId = null;
                        }
                    } else if (!timeoutId) {
                        // If not enough time has passed, but no timeout is scheduled, schedule one
                        timeoutId = setTimeout(() => {
                            lastRan = Date.now();
                            func.apply(lastThis, lastArgs);
                            timeoutId = null;
                            lastArgs = null;
                            lastThis = null;
                        }, limit - (now - lastRan));
                    }
                };
                return throttled;
            }

            // Event listener for saving API key
            saveApiKeyBtn.addEventListener('click', () => {
                userGeminiApiKey = geminiApiKeyInput.value.trim();
                storyModal.classList.add('active'); // Show modal
                isModalOpen = true; // Set modal state

                // Reset modal content and visibility for API key messages
                setInteractiveFeaturesVisibility(false); // Hide interactive features
                modalLoadingStory.style.display = 'none';
                qaLoading.style.display = 'none';
                answerOutput.textContent = '';
                questionInput.value = '';
                showTab('story'); // Ensure story tab is active for messages
                stopSpeaking(); // Stop any speech when modal opens for API key message
                updateSpeechButtons(false, false); // Disable speech buttons for API key message

                if (userGeminiApiKey === "") {
                    localStorage.removeItem('geminiApiKey');
                    modalMainTitle.textContent = "提示";
                    modalStoryContent.textContent = "API 金鑰已消除。要使用相關功能需重新設定。。";
                    geminiApiKeyInput.type = "text"; // Display as text after clearing
                } else {
                    localStorage.setItem('geminiApiKey', userGeminiApiKey); // Save to localStorage
                    modalMainTitle.textContent = "提示";
                    modalStoryContent.textContent = "您的 Gemini API 金鑰已成功儲存。現在您可以點擊圖片來生成故事與圖片問答。";
                    geminiApiKeyInput.type = "password"; // Display as password after setting
                }
                initializeGeminiModel(); // Re-initialize model after saving key

                // Auto-close the modal after 3 seconds for API key messages
                setTimeout(() => {
                    closeAnyModal(); // Use unified close function
                }, 3000);
            });

            // Event listener for clearing API key
            clearApiKeyBtn.addEventListener('click', () => {
                userGeminiApiKey = ""; // Clear the variable
                localStorage.removeItem('geminiApiKey'); // Remove key from localStorage
                geminiApiKeyInput.value = ""; // Clear the input field
                geminiApiKeyInput.type = "text"; // Display as text after clearing
                
                storyModal.classList.add('active'); // Show modal
                isModalOpen = true; // Set modal state

                // Reset modal content and visibility for API key messages
                setInteractiveFeaturesVisibility(false); // Hide interactive features
                modalLoadingStory.style.display = 'none';
                qaLoading.style.display = 'none';
                answerOutput.textContent = '';
                questionInput.value = '';
                showTab('story'); // Ensure story tab is active for messages
                stopSpeaking(); // Stop any speech when modal opens for API key message
                updateSpeechButtons(false, false); // Disable speech buttons for API key message

                modalMainTitle.textContent = "提示";
                modalStoryContent.textContent = "API 金鑰已消除。要使用相關功能需重新設定。";
                initializeGeminiModel(); // Re-initialize model after clearing key

                // Auto-close the modal after 3 seconds for API key messages
                setTimeout(() => {
                    closeAnyModal(); // Use unified close function
                }, 3000);
            });


            // Initialize Generative AI model (will re-initialize if API key changes)
            let genAI = null; // Initialize as null
            let model = null; // Initialize as null

            function initializeGeminiModel() {
                if (userGeminiApiKey) {
                    genAI = new GoogleGenerativeAI(userGeminiApiKey);
                    model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" }); 
                } else {
                    genAI = null;
                    model = null; // Ensure they are reset if no key
                }
            }

            initializeGeminiModel(); // Initialize on load

            // Define photo data for different categories
            const photoCategories = {
                nature: {
                    title: "自然風光",
                    description: "欣賞大自然的壯麗景色，包括山脈、森林、湖泊、海洋等令人驚嘆的自然景觀。每張照片都捕捉到了大自然的美麗瞬間。",
                    query: "nature landscape"
                },
                architecture: {
                    title: "建築設計",
                    description: "探索世界各地的建築傑作，從古老的歷史建築到現代的標誌性地標，每張照片都展示了人類創造力的巔峰。",
                    query: "architecture building"
                },
                people: {
                    title: "人物肖像",
                    description: "捕捉世界各地人物的獨特表情和故事，每張肖像都展現了人類多樣性和個體魅力。",
                    query: "people portrait"
                },
                animals: {
                    title: "動物世界",
                    description: "探索地球上最迷人的動物，從野生叢林到海洋深處，每張照片都展示了動物王國的奇妙之處。",
                    query: "animals wildlife"
                },
                abstract: {
                    title: "抽象藝術",
                    description: "欣賞富有創意的抽象藝術作品，透過色彩、形狀和構圖表達深刻的情感和思想。",
                    query: "abstract art"
                },
                food: {
                    title: "美食攝影",
                    description: "探索世界各地的美食文化，從精緻的高級料理到道地的街頭小吃，每張照片都喚起您的味蕾體驗。",
                    query: "food photography"
                },
                city: {
                    title: "城市景觀",
                    description: "捕捉城市的活力與魅力，從繁忙的都市街道到寧靜的巷弄角落，每張照片都講述著城市的故事。",
                    query: "cityscape urban"
                },
                travel: {
                    title: "旅行紀實",
                    description: "體驗不同文化的獨特魅力。每張照片都帶您體驗不同文化的獨特魅力。",
                    query: "travel adventure"
                },
                night: {
                    title: "夜景攝影",
                    description: "欣賞夜幕降臨後的城市與自然之美，從燈火輝煌的都市天際線到繁星點點的夜空，每張照片都展現夜晚的神秘魅力。",
                    query: "night photography"
                },
                macro: {
                    title: "微距攝影",
                    description: "探索微小世界的奇妙細節，從昆蟲的翅膀到花朵的結構，每張照片都揭示了肉眼難以察覺的精緻之美。",
                    query: "macro photography"
                },
                custom_album: { // Placeholder for custom album, photos will be dynamically loaded
                    title: "自訂圖片集",
                    description: "您載入的自訂圖片集，每次顯示 8 張，可點擊「載入更多」查看下一批。",
                    query: null // No query needed for local files
                },
                pexels_photos: { // New category for Pexels photos
                    title: "Pexels 圖片庫",
                    description: "從 Pexels API 隨機獲取策展圖片。每次載入 8 張，可點擊「載入更多」查看下一批。",
                    query: "" // Empty query for curated photos
                },
                pixabay_photos: { // New category for Pixabay photos
                    title: "Pixabay 圖片庫",
                    description: "從 Pixabay API 隨機獲取圖片。每次載入 8 張，可點擊「載入更多」查看下一批。",
                    query: "" // Empty query for random popular photos
                },
                pokemon_gallery: { // New category for Pokemon gallery
                    title: "寶可夢圖片庫",
                    description: "從 PokéAPI 獲取寶可夢圖片及詳細資訊，提供即時搜尋功能，並以卡片式介面呈現。每次載入 20 隻寶可夢，並可透過「載入更多」按鈕載入下一批。",
                    query: null // No specific query for PokeAPI
                }
            };

            const carousel = document.getElementById('carousel');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const indicators = document.getElementById('indicators');
            const categoryTitle = document.getElementById('categoryTitle');
            const categoryDesc = document.getElementById('categoryDesc');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const categoryBtns = document.querySelectorAll('.category-btn');
            
            let currentImageForQA = null; // Stores current image info for QA function
            
            let currentRotation = 0;
            const rotationStep = 45;
            const totalItems = 8; // Fixed number of photos per category (for display purposes)
            let currentCategory = 'nature';
            let autoPlayInterval;
            
            // Function: Switch tabs in the modal
            function showTab(tabName) {
                // Ensure only story content area is visible by default for API messages
                if (tabName === 'story') {
                    storyContentArea.style.display = 'block';
                    qaContentArea.style.display = 'none';
                    storyTabBtn.classList.add('bg-primary', 'hover:bg-blue-700');
                    storyTabBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                    qaTabBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
                    qaTabBtn.classList.remove('bg-primary', 'hover:bg-blue-700');
                } else if (tabName === 'qa') {
                    storyContentArea.style.display = 'none';
                    qaContentArea.style.display = 'block';
                    qaTabBtn.classList.add('bg-primary', 'hover:bg-blue-700');
                    qaTabBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                    storyTabBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
                    storyTabBtn.classList.remove('bg-primary', 'hover:bg-blue-700');
                    // When switching to QA tab, clear previous answer and input
                    answerOutput.textContent = '';
                    questionInput.value = '';
                }
                stopSpeaking(); // Stop any speech when switching tabs
                updateSpeechButtons(false, false); // Disable speech buttons until content is ready
            }

            // Tab button event listeners
            storyTabBtn.addEventListener('click', () => showTab('story'));
            qaTabBtn.addEventListener('click', () => showTab('qa'));

            // Initialize gallery
            function initGallery() {
                loadCategoryPhotos(currentCategory);
                setupCategoryButtons();
                setupNavigation();
                setupDrag(); // Call setupDrag
                setupAutoPlay(); // Initial call to start auto-play
                setupModalEvents(); // Set up modal events
                setupCustomAlbumModalEvents(); // Set up custom album modal events
                setupPokemonGalleryEvents(); // Set up Pokemon gallery events
                updateSpeechButtons(false, false); // Initialize speech buttons as disabled
            }
            
            // Function to fetch random or queried images from Pexels Photos
            async function fetchPexelsPhotos(query, page, limit = 8) {
                if (!PEXELS_API_KEY || PEXELS_API_KEY === 'YOUR_PEXELS_API_KEY') {
                    console.error("Pexels API Key is not set. Please replace 'YOUR_PEXELS_API_KEY' with your actual key from https://www.pexels.com/api/");
                    return [];
                }
                const apiUrl = query
                    ? `https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&page=${page}&per_page=${limit}`
                    : `https://api.pexels.com/v1/curated?page=${page}&per_page=${limit}`; // Use curated for empty query

                try {
                    const response = await fetch(apiUrl, {
                        headers: {
                            Authorization: PEXELS_API_KEY
                        }
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    return data.photos.map(item => ({
                        id: item.id,
                        src: item.src.large2x, // Use a high-quality source
                        alt: item.alt || `Pexels Photo by ${item.photographer}`
                    }));
                } catch (error) {
                    console.error("Error fetching Pexels photos:", error);
                    return [];
                }
            }

            // Function to fetch random images from Pixabay Photos
            async function fetchPixabayPhotos(query, page, limit = 8) {
                if (!PIXABAY_API_KEY || PIXABAY_API_KEY === 'YOUR_PIXABAY_API_KEY') {
                    console.error("Pixabay API Key is not set. Please replace 'YOUR_PIXABAY_API_KEY' with your actual key from https://pixabay.com/api/docs/");
                    return [];
                }
                try {
                    // Pixabay API doesn't have a curated endpoint like Pexels, so we'll use a general search with empty query
                    // to get somewhat random popular images. You can add a 'q' parameter for specific searches if needed.
                    const pixabayQuery = query ? `&q=${encodeURIComponent(query)}` : '';
                    const response = await fetch(`https://pixabay.com/api/?key=${PIXABAY_API_KEY}&image_type=photo&per_page=${limit}&page=${page}${pixabayQuery}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    return data.hits.map(item => ({
                        id: item.id,
                        src: item.webformatURL, // Use webformatURL for display
                        alt: item.tags // Use tags as alt text
                    }));
                } catch (error) {
                    console.error("Error fetching Pixabay photos:", error);
                    return [];
                }
            }

            // Function to fetch Pokemon data from PokeAPI
            async function fetchPokemonData(offset, limit) {
                console.log(`[Pokemon Gallery] Fetching Pokemon from offset: ${offset}, limit: ${limit}`); // Debug log
                try {
                    const response = await fetch(`https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    console.log('[Pokemon Gallery] PokeAPI raw response data:', data); // Debug log: raw response
                    
                    const pokemonDetailsPromises = data.results.map(async (pokemon) => {
                        const detailResponse = await fetch(pokemon.url);
                        if (!detailResponse.ok) {
                            console.warn(`[Pokemon Gallery] Could not fetch details for ${pokemon.name}`);
                            return null;
                        }
                        const detailData = await detailResponse.json();
                        return {
                            id: detailData.id,
                            name: detailData.name,
                            sprite: detailData.sprites.front_default, // Default sprite
                            height: detailData.height / 10, // Convert decimetres to meters
                            weight: detailData.weight / 10, // Convert hectograms to kilograms
                            types: detailData.types.map(typeInfo => typeInfo.type.name)
                        };
                    });
                    const detailedPokemon = (await Promise.all(pokemonDetailsPromises)).filter(p => p !== null);
                    console.log(`[Pokemon Gallery] Fetched ${detailedPokemon.length} detailed Pokemon.`); // Debug log: number of detailed Pokemon
                    return {
                        pokemon: detailedPokemon,
                        next: data.next !== null // Check if there's a 'next' URL for more results
                    };
                } catch (error) {
                    console.error("[Pokemon Gallery] Error fetching Pokemon data:", error);
                    return { pokemon: [], next: false };
                }
            }


            // Load category photos
            async function loadCategoryPhotos(category, append = false) {
                showLoading(true);
                
                const isPokemonGallery = (category === 'pokemon_gallery');

                // Clear carousel and indicators for non-Pokemon categories
                if (!isPokemonGallery) {
                    carousel.innerHTML = '';
                    indicators.innerHTML = '';
                    currentRotation = 0;
                    carousel.style.transform = `rotateY(${currentRotation}deg)`;
                    loadMoreBtn.style.display = 'none'; // Default to hidden for carousel categories
                    pokemonSearchInput.style.display = 'none'; // Hide search input
                    mainGalleryContent.style.display = 'block'; // Ensure main gallery is visible
                    pokemonGallerySection.style.display = 'none'; // Hide pokemon section
                }

                // Handle Pokemon specific setup on initial load (only clear/reset if not appending)
                if (isPokemonGallery && !append) {
                    mainGalleryContent.style.display = 'none'; // Hide main gallery
                    pokemonGallerySection.style.display = 'block'; // Show pokemon section
                    pokemonSearchInput.style.display = 'block'; // Show search input
                    
                    allPokemonData = []; // Clear data for fresh start
                    pokemonOffset = 0;
                    pokemonGrid.innerHTML = ''; // Explicitly clear grid only on initial Pokemon category load
                    pokemonSearchInput.value = ''; // Clear search input
                    loadMoreBtn.style.display = 'none'; // Hide load more initially
                    console.log("[Pokemon Gallery] Initial load: Resetting state and clearing grid.");
                }

                // Get current category data
                const categoryData = photoCategories[category];
                if (!categoryData && !isPokemonGallery && category !== 'custom_album' && category !== 'instructions') {
                    showLoading(false);
                    return;
                }

                let photosToDisplay = [];

                if (category === 'custom_album') {
                    const startIndex = append ? customAlbumCurrentIndex : 0;
                    const endIndex = Math.min(customAlbumFiles.length, startIndex + imagesPerLoad);
                    
                    if (!append) { 
                        customAlbumCurrentIndex = 0; 
                    }

                    if (customAlbumFiles.length === 0) {
                        categoryTitle.textContent = "自訂圖片集";
                        categoryDesc.textContent = "請點擊「自訂圖片集」按鈕選擇一個資料夾載入您的圖片。";
                        showLoading(false);
                        return;
                    }

                    photosToDisplay = customAlbumFiles.slice(startIndex, endIndex).map(file => ({
                        id: file.name,
                        src: URL.createObjectURL(file),
                        alt: file.name,
                        isLocalFile: true,
                        fileObject: file
                    }));

                    customAlbumCurrentIndex = endIndex;
                    if (customAlbumCurrentIndex < customAlbumFiles.length) {
                        loadMoreBtn.style.display = 'block';
                    } else {
                        loadMoreBtn.style.display = 'none';
                    }

                    categoryTitle.textContent = categoryData.title;
                    categoryDesc.textContent = categoryData.description;

                } else if (category === 'pexels_photos') {
                    if (!append) {
                        pexelsPage = Math.floor(Math.random() * 50) + 1; 
                    }
                    if (!PEXELS_API_KEY || PEXELS_API_KEY === 'YOUR_PEXELS_API_KEY') {
                        categoryTitle.textContent = "Pexels 圖片庫";
                        categoryDesc.textContent = "Pexels API 金鑰未設定。請替換程式碼中的 'YOUR_PEXELS_API_KEY' 為您的實際金鑰，可從 https://www.pexels.com/api/ 獲取。";
                        showLoading(false);
                        return;
                    }

                    photosToDisplay = await fetchPexelsPhotos(categoryData.query, pexelsPage, imagesPerLoad);
                    if (photosToDisplay.length > 0) {
                        pexelsPage++;
                        if (photosToDisplay.length === imagesPerLoad) { 
                            loadMoreBtn.style.display = 'block';
                        } else {
                            loadMoreBtn.style.display = 'none'; 
                        }
                    } else {
                        loadMoreBtn.style.display = 'none';
                        categoryTitle.textContent = "Pexels 圖片庫";
                        categoryDesc.textContent = "無法載入 Pexels 圖片，請檢查您的 API 金鑰是否有效，或稍後再試。";
                        showLoading(false);
                        return;
                    }
                    categoryTitle.textContent = categoryData.title;
                    categoryDesc.textContent = categoryData.description;
                } else if (category === 'pixabay_photos') {
                    if (!append) {
                        pixabayPage = Math.floor(Math.random() * 50) + 1; 
                    }
                    if (!PIXABAY_API_KEY || PIXABAY_API_KEY === 'YOUR_PIXABAY_API_KEY') {
                        categoryTitle.textContent = "Pixabay 圖片庫";
                        categoryDesc.textContent = "Pixabay API 金鑰未設定。請替換程式碼中的 'YOUR_PIXABAY_API_KEY' 為您的實際金鑰，可從 https://pixabay.com/api/docs/ 為您的實際金鑰。";
                        showLoading(false);
                        return;
                    }

                    photosToDisplay = await fetchPixabayPhotos(categoryData.query, pixabayPage, imagesPerLoad);
                    if (photosToDisplay.length > 0) {
                        pixabayPage++;
                        if (photosToDisplay.length === imagesPerLoad) { 
                            loadMoreBtn.style.display = 'block';
                        } else {
                            loadMoreBtn.style.display = 'none';
                        }
                    } else {
                        loadMoreBtn.style.display = 'none';
                        categoryTitle.textContent = "Pixabay 圖片庫";
                        categoryDesc.textContent = "無法載入 Pixabay 圖片，請檢查您的 API 金鑰是否有效，或稍後再試。";
                        showLoading(false);
                        return;
                    }
                    categoryTitle.textContent = categoryData.title;
                    categoryDesc.textContent = categoryData.description;
                } else if (isPokemonGallery) {
                    console.log(`[Pokemon Gallery] Fetching and appending Pokemon. Append: ${append}, currentOffset: ${pokemonOffset}`);
                    const { pokemon, next } = await fetchPokemonData(pokemonOffset, pokemonLimit);
                    allPokemonData = allPokemonData.concat(pokemon); // Accumulate all pokemon
                    
                    displayedPokemon = allPokemonData; // Always update displayed list to reflect all fetched
                    renderPokemonCards(displayedPokemon); // Re-render the grid with all accumulated data

                    pokemonOffset += pokemon.length;
                    if (next) {
                        loadMoreBtn.style.display = 'block';
                    } else {
                        loadMoreBtn.style.display = 'none';
                    }
                    categoryTitle.textContent = categoryData.title;
                    categoryDesc.textContent = categoryData.description;

                } else if (category === 'instructions') {
                    displayInstructionsModal();
                    showLoading(false);
                    return;
                } else { // Default static Pexels categories (nature, architecture, etc.)
                    // These always load exactly 8 images (or fewer if API cannot provide), and DO NOT support "Load More"
                    photosToDisplay = await fetchPexelsPhotos(categoryData.query, 1, imagesPerLoad); // Always page 1 for these
                    loadMoreBtn.style.display = 'none'; // Ensure hidden for these static categories

                    if (photosToDisplay.length === 0) {
                        categoryTitle.textContent = categoryData.title;
                        categoryDesc.textContent = "無法載入圖片，請檢查您的 API 金鑰是否有效，或稍後再試。";
                        showLoading(false);
                        return;
                    }
                    categoryTitle.textContent = categoryData.title;
                    categoryDesc.textContent = categoryData.description;
                }

                // Render carousel items only if not Pokemon gallery
                if (!isPokemonGallery) {
                    photosToDisplay.forEach((photo, index) => {
                        const item = document.createElement('div');
                        item.className = 'carousel-item';
                        item.style.setProperty('--i', index % totalItems); 
                        
                        const img = document.createElement('img');
                        img.src = photo.src;
                        img.alt = photo.alt;
                        img.onerror = function() {
                            this.onerror=null;
                            this.src=`https://placehold.co/600x800/FF0000/FFFFFF?text=Image+Not+Found%0A${encodeURIComponent(photo.src)}`; 
                            console.error(`Failed to load image: ${photo.src}`);
                        };
                        img.addEventListener('click', () => {
                            if (isModalOpen) return;
                            if (isCarouselRunning) {
                                clearInterval(autoPlayInterval);
                                isCarouselRunning = false;
                            }
                            isModalOpen = true;
                            generateStoryForImage(photo.isLocalFile ? photo.fileObject : photo.src, photo.alt, photo.isLocalFile);
                        });
                        item.appendChild(img);
                        carousel.appendChild(item);
                        
                        const indicator = document.createElement('div');
                        indicator.className = `indicator ${index === 0 ? 'active' : ''} animate-fade-in`;
                        indicator.style.animationDelay = `${0.6 + (index * 0.1)}s`;
                        indicator.addEventListener('click', () => {
                            if (isCarouselRunning) {
                                clearInterval(autoPlayInterval);
                                isCarouselRunning = false;
                            }
                            const targetRotation = index * -rotationStep;
                            const diff = targetRotation - currentRotation;
                            const steps = Math.round(diff / rotationStep);
                            rotateCarousel(steps * rotationStep);
                        });
                        indicators.appendChild(indicator);
                    });
                    
                    for (let i = photosToDisplay.length; i < totalItems; i++) {
                        const item = document.createElement('div');
                        item.className = 'carousel-item';
                        item.style.setProperty('--i', i);
                        
                        const img = document.createElement('img');
                        img.src = `https://placehold.co/600x800/2A374F/F8FAFC?text=Empty+Slot`;
                        img.alt = "Empty Slot";
                        item.appendChild(img);
                        carousel.appendChild(item);

                        const indicator = document.createElement('div');
                        indicator.className = `indicator animate-fade-in`;
                        indicator.style.animationDelay = `${0.6 + (i * 0.1)}s`;
                        indicators.appendChild(indicator);
                    }
                }

                setTimeout(() => {
                    showLoading(false);
                }, 500);
            }
            
            // Set up category buttons
            function setupCategoryButtons() {
                // Throttled version of loadCategoryPhotos for category buttons
                const throttledLoadCategoryPhotos = throttle(
                    loadCategoryPhotos,
                    2000 // 2 seconds throttle limit for API calls
                );

                categoryBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const category = btn.getAttribute('data-category');
                        
                        // Update current category
                        currentCategory = category;
                        
                        // Update button styles
                        categoryBtns.forEach(b => b.classList.remove('category-active'));
                        btn.classList.add('category-active');
                        
                        if (category === 'custom_album') {
                            customAlbumModal.classList.add('active');
                            isModalOpen = true;
                            // Pause carousel if it's running when custom album modal opens
                            if (isCarouselRunning) {
                                clearInterval(autoPlayInterval);
                                isCarouselRunning = false;
                            }
                            // Reset file input value to allow selecting the same folder again
                            customAlbumFileInput.value = ''; 
                        } else if (category === 'instructions') {
                            displayInstructionsModal();
                        }
                        else {
                            // Use throttled function for category photo loading
                            throttledLoadCategoryPhotos(category);
                            // Resume auto-play when a new category is selected, unless it's Pokemon
                            if (category !== 'pokemon_gallery') {
                                setupAutoPlay();
                            } else {
                                clearInterval(autoPlayInterval); // Stop auto-play for Pokemon gallery
                                isCarouselRunning = false;
                            }
                        }
                    });
                });
            }
            
            // Set up navigation buttons
            function setupNavigation() {
                prevBtn.addEventListener('click', () => {
                    rotateCarousel(rotationStep);
                    // Resume auto-play if nav button is clicked
                    setupAutoPlay(); 
                });
                nextBtn.addEventListener('click', () => {
                    rotateCarousel(-rotationStep);
                    // Resume auto-play if nav button is clicked
                    setupAutoPlay(); 
                });
            }
            
            // Set up drag functionality
            function setupDrag() {
                let isDragging = false;
                let startX;
                let startRotation = 0;

                // Global variables for drag throttling
                let lastDragExecutionTime = 0;
                const dragThrottleDuration = 200; // milliseconds, increased for smoother drag

                // Throttled version of the drag function
                const throttledDrag = function(e) {
                    const now = Date.now();
                    // Only apply throttle if it's not the first drag event in a sequence
                    if (now - lastDragExecutionTime < dragThrottleDuration) {
                        // No warning here, just return early
                        return;
                    }
                    lastDragExecutionTime = now;

                    // Original drag logic starts here
                    if (!isDragging) return;
                    const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                    const diffX = (clientX - startX) * 0.5; // Adjust drag sensitivity
                    currentRotation = startRotation - diffX;
                    carousel.style.transform = `rotateY(${currentRotation}deg)`;
                    // Original drag logic ends here
                };
                
                carousel.addEventListener('mousedown', startDrag);
                carousel.addEventListener('touchstart', startDrag, { passive: true });
                
                document.addEventListener('mousemove', throttledDrag); // Use throttled version
                document.addEventListener('touchmove', throttledDrag, { passive: true }); // Use throttled version
                
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag);
                
                function startDrag(e) {
                    isDragging = true;
                    startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                    startRotation = currentRotation;
                    carousel.style.transition = 'none'; // Remove transition during drag
                    // Pause auto-play when dragging starts
                    clearInterval(autoPlayInterval);
                    isCarouselRunning = false;
                    lastDragExecutionTime = Date.now(); // Reset for a new drag sequence
                }
                
                function drag(e) { // This original `drag` function is now replaced by `throttledDrag` in event listeners.
                    // Keep this empty or remove if not used elsewhere, to avoid confusion.
                }
                
                function endDrag() {
                    isDragging = false;
                    carousel.style.transition = 'transform 0.5s ease-out'; // Restore transition after drag
                    
                    // Snap to the nearest image position
                    const roundedRotation = Math.round(currentRotation / rotationStep) * rotationStep;
                    currentRotation = roundedRotation;
                    carousel.style.transform = `rotateY(${currentRotation}deg)`;
                    updateIndicators();
                    // Resume auto-play after dragging ends
                    setupAutoPlay();
                }
            }
            
            // Set up auto-play
            function setupAutoPlay() {
                clearInterval(autoPlayInterval); // Always clear existing interval
                isCarouselRunning = true; // Set state to running when auto-play is initiated
                autoPlayInterval = setInterval(() => {
                    // Only rotate if no modal is open, carousel is marked as running, and not Pokemon gallery
                    if (!isModalOpen && isCarouselRunning && currentCategory !== 'pokemon_gallery') {
                        rotateCarousel(-rotationStep); // Rotate to the next image
                    }
                }, 4000); // Auto-rotate every 4 seconds (changed from 5000ms)
                
                // Pause auto-play on mouse hover
                carousel.addEventListener('mouseenter', () => {
                    if (isCarouselRunning && !isModalOpen && currentCategory !== 'pokemon_gallery') { // Only clear if it was running and no modal is open
                        clearInterval(autoPlayInterval);
                    }
                });
                
                // Resume auto-play on mouse leave
                carousel.addEventListener('mouseleave', () => {
                    if (isCarouselRunning && !isModalOpen && currentCategory !== 'pokemon_gallery') { // Only resume if it should be running and no modal is open
                        setupAutoPlay(); // Call setupAutoPlay to restart the interval
                    }
                });
            }
            
            // Update indicators
            function updateIndicators() {
                // Calculate current active photo index
                const activeIndex = Math.round((-currentRotation % 360) / rotationStep);
                // Ensure index is within valid range, handle negative numbers
                const normalizedActiveIndex = (activeIndex % totalItems + totalItems) % totalItems;

                Array.from(indicators.children).forEach((indicator, index) => {
                    if (index === normalizedActiveIndex) {
                        indicator.classList.add('active');
                    } else {
                        indicator.classList.remove('active');
                    }
                });
            }
            
            // Rotate gallery
            function rotateCarousel(step) {
                currentRotation += step;
                carousel.style.transform = `rotateY(${currentRotation}deg)`;
                updateIndicators();
            }
            
            // Show/hide loading animation
            function showLoading(show) {
                if (show) {
                    loadingOverlay.classList.add('active');
                } else {
                    loadingOverlay.classList.remove('active');
                }
            }

            // Set up modal events for story/QA modal
            function setupModalEvents() {
                closeModalBtn.addEventListener('click', () => {
                    closeAnyModal(); // Use unified close function
                });

                storyModal.addEventListener('click', (e) => {
                    if (e.target === storyModal) { // Clicked outside the modal content
                        closeAnyModal(); // Use unified close function
                    }
                });

                // Speech control button event listeners
                playStoryBtn.addEventListener('click', () => {
                    if (modalStoryContent.textContent) {
                        speakText(modalStoryContent.textContent);
                    }
                });
                stopStoryBtn.addEventListener('click', stopSpeaking);

                playQaBtn.addEventListener('click', () => {
                    if (answerOutput.textContent) {
                        speakText(answerOutput.textContent);
                    }
                });
                stopQaBtn.addEventListener('click', stopSpeaking);
            }

            // Set up events for custom album modal
            function setupCustomAlbumModalEvents() {
                closeCustomAlbumModalBtn.addEventListener('click', () => {
                    closeAnyModal(); // Use unified close function
                });

                // Handle folder selection when files are chosen
                customAlbumFileInput.addEventListener('change', (event) => {
                    const files = event.target.files;
                    if (files.length > 0) {
                        // Filter for image files
                        customAlbumFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                        customAlbumCurrentIndex = 0; // Reset index for new album
                        loadCategoryPhotos('custom_album'); // Load first batch
                        customAlbumModal.classList.remove('active');
                        isModalOpen = false;
                        // Resume auto-play after loading custom album
                        setupAutoPlay();
                    } else {
                        // Using a custom message box instead of alert()
                        const messageBox = document.createElement('div');
                        messageBox.style.cssText = `
                            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                            background: #333; color: white; padding: 20px; border-radius: 10px;
                            box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 1000;
                            text-align: center;
                        `;
                        messageBox.innerHTML = `
                            <p>沒有選擇任何圖片檔案！</p>
                            <button style="margin-top: 10px; padding: 8px 15px; background: #165DFF; color: white; border: none; border-radius: 5px; cursor: pointer;">確定</button>
                        `;
                        document.body.appendChild(messageBox);
                        messageBox.querySelector('button').addEventListener('click', () => {
                            document.body.removeChild(messageBox);
                        });
                    }
                });

                // Throttled version of loadCategoryPhotos for loadMoreBtn
                const throttledLoadMore = throttle(
                    (category, append) => loadCategoryPhotos(category, append),
                    2000 // 2 seconds throttle limit
                );

                loadMoreBtn.addEventListener('click', () => {
                    console.log('[Load More] button clicked for category:', currentCategory); // Debug log
                    if (currentCategory === 'custom_album' || currentCategory === 'pexels_photos' || currentCategory === 'pixabay_photos' || currentCategory === 'pokemon_gallery') {
                        throttledLoadMore(currentCategory, true); // Use throttled function
                        // Auto-play should remain paused for Pokemon gallery.
                        // For custom/pexels/pixabay, auto-play resumes after throttledLoadMore is called.
                        if (currentCategory !== 'pokemon_gallery') {
                            setupAutoPlay();
                        }
                    }
                });
            }

            // Set up Pokemon gallery events
            function setupPokemonGalleryEvents() {
                pokemonSearchInput.addEventListener('input', () => {
                    const searchTerm = pokemonSearchInput.value.toLowerCase();
                    const filteredPokemon = allPokemonData.filter(pokemon =>
                        pokemon.name.toLowerCase().includes(searchTerm)
                    );
                    renderPokemonCards(filteredPokemon);
                });
            }

            // Function to render Pokemon cards
            function renderPokemonCards(pokemonArray) {
                console.log(`[Pokemon Gallery] Rendering Pokemon cards. Array length: ${pokemonArray.length}`); // Debug log
                pokemonGrid.innerHTML = ''; // Clear existing cards before rendering the current set of displayed Pokemon
                if (pokemonArray.length === 0) {
                    pokemonGrid.innerHTML = '<p class="text-gray-400 text-lg mt-4">找不到寶可夢。</p>';
                    return;
                }

                pokemonArray.forEach(pokemon => {
                    const card = document.createElement('div');
                    card.className = 'pokemon-card';
                    card.innerHTML = `
                        <img src="${pokemon.sprite || 'https://placehold.co/120x120/4A5568/F8FAFC?text=No+Image'}" alt="${pokemon.name}">
                        <h5>${pokemon.name}</h5>
                        <p>身高: ${pokemon.height} m</p>
                        <p>體重: ${pokemon.weight} kg</p>
                        <div class="pokemon-types">
                            ${pokemon.types.map(type => `<span class="pokemon-type-badge">${type}</span>`).join('')}
                        </div>
                    `;
                    // Add click listener to Pokemon cards for story/QA
                    card.addEventListener('click', () => {
                        if (isModalOpen) return;
                        // Use the sprite as the image source for story/QA
                        generateStoryForImage(pokemon.sprite, pokemon.name, false); 
                    });
                    pokemonGrid.appendChild(card);
                });
            }


            // Helper function: Convert image URL to Base64
            async function urlToBase64(url) {
                try {
                    const response = await fetch(url);
                    // Check if response is successful (status code 200)
                    if (!response.ok) {
                        throw new Error(`HTTP Error! Status: ${response.status}, URL: ${url}`);
                    }
                    const blob = await response.blob();
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result.split(',')[1]); // Get Base64 string without "data:image/jpeg;base64," prefix
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (error) {
                    console.error("Error converting image to Base64:", error);
                    throw new Error("Could not load image to generate story. Please ensure the image URL is publicly accessible.");
                }
            }

            // Helper function: Convert File object to Base64
            async function fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        if (reader.result) {
                            resolve(reader.result.split(',')[1]); // Get Base64 string without prefix
                        } else {
                            reject(new Error("FileReader result is null."));
                        }
                    };
                    reader.onerror = (error) => reject(error);
                    reader.readAsDataURL(file);
                });
            }

            // Function: Generate story for image using Gemini API
            async function generateStoryForImage(imageSource, imageAlt, isLocalFile = false) {
                currentImageForQA = { source: imageSource, alt: imageAlt, isLocalFile: isLocalFile }; // Store source and type
                storyModal.classList.add('active'); // Show modal
                isModalOpen = true; // Set modal state
                stopSpeaking(); // Stop any ongoing speech
                updateSpeechButtons(false, false); // Disable speech buttons during loading

                // **Core modification: Hide all interactive features first, then decide whether to show based on key status**
                setInteractiveFeaturesVisibility(false); // Hide all tab buttons and QA block
                modalStoryTitle.style.display = 'block'; // API Key message will use this, so ensure it's visible for the message itself
                modalStoryContent.textContent = '';
                modalLoadingStory.style.display = 'none';
                qaLoading.style.display = 'none';
                answerOutput.textContent = '';
                questionInput.value = '';
                
                modalMainTitle.textContent = "提示"; // Default main title to "Hint"

                if (!userGeminiApiKey) {
                    modalStoryContent.textContent = "API 金鑰未設定。請在主頁輸入您的 Gemini API 金鑰。";
                    return; // Key not set, exit directly without making API call
                }

                // If key exists, show interactive features and continue with API call
                setInteractiveFeaturesVisibility(true); // Show tab buttons and QA block
                setTabButtonsEnabled(true); // Enable tab buttons (control grayscale/mouse)
                showTab('story'); // Default to showing image story tab
                
                modalMainTitle.textContent = "圖片故事與問答"; // Restore main title
                modalStoryTitle.textContent = `正在為 "${imageAlt}" 生成故事...`;
                modalLoadingStory.style.display = 'block';

                try {
                    let base64Image;
                    let mimeType;

                    if (isLocalFile) {
                        base64Image = await fileToBase64(currentImageForQA.source); // imageSource is a File object
                        mimeType = currentImageForQA.source.type; // Get MIME type from File object
                    } else {
                        base64Image = await urlToBase64(currentImageForQA.source); // imageSource is a URL string
                        // Attempt to infer MIME type from URL or default to jpeg
                        mimeType = currentImageForQA.source.endsWith('.png') ? 'image/png' : currentImageForQA.source.endsWith('.gif') ? 'image/gif' : 'image/jpeg';
                    }

                    const result = await model.generateContent([
                        { text: "請為這張圖片生成一個大約100字以內的富有想像力的簡短故事或描述。內容應圍繞著圖片本身，風格可以是抒情、奇幻或富有哲理，請避免生成過於暴力或不適宜的內容。如果圖片無法識別，請回應'無法為這張圖片生成故事。'" },
                        {
                            inlineData: {
                                mimeType: mimeType, 
                                data: base64Image
                            }
                        }
                    ]);

                    const response = await result.response;
                    let text = response.text();

                    // Safety settings check
                    const safetyRatings = response.promptFeedback?.safetyRatings || [];
                    const blockedReason = response.promptFeedback?.blockReason;

                    if (blockedReason) {
                        text = `內容被阻止。原因: ${blockedReason}。部分內容可能觸發了以下安全設定:\n${safetyRatings.map(rating => `${rating.category}: ${rating.probability}`).join('\n')}`;
                    } else if (text.trim() === '') {
                        text = "無法為這張圖片生成故事，請稍後再試。";
                    }

                    modalStoryTitle.textContent = `"${imageAlt}" 的故事`;
                    modalStoryContent.textContent = text;
                    updateSpeechButtons(true, false); // Enable play button after content is loaded
                } catch (error) {
                    console.error("生成故事時出錯:", error);
                    modalStoryTitle.textContent = `"${imageAlt}" 的故事`;
                    modalStoryContent.textContent = "抱歉，生成故事時發生錯誤。請檢查您的 API 金鑰是否有效，或稍後再試。";
                    updateSpeechButtons(false, false); // Disable speech buttons on error
                } finally {
                    modalLoadingStory.style.display = 'none';
                }
            }

            // Function: Answer image-related questions using Gemini API
            askQuestionBtn.addEventListener('click', async () => {
                const questionText = questionInput.value.trim();
                if (!questionText) {
                    answerOutput.textContent = "請輸入您的問題。";
                    updateSpeechButtons(false, false); // Disable speech buttons if no question
                    return;
                }
                if (!currentImageForQA) {
                    answerOutput.textContent = "沒有選中要提問的圖片。請先點擊畫廊中的一張圖片。";
                    updateSpeechButtons(false, false); // Disable speech buttons if no image
                    return;
                }
                if (!userGeminiApiKey) { // Check API key again, although it was checked when clicking the image
                    answerOutput.textContent = "API 金鑰未設定。請在主頁輸入您的 Gemini API 金鑰。";
                    updateSpeechButtons(false, false); // Disable speech buttons if no API key
                    return;
                }

                answerOutput.textContent = ''; // Clear previous answer
                qaLoading.style.display = 'block'; // Show QA loading indicator
                stopSpeaking(); // Stop any ongoing speech
                updateSpeechButtons(false, false); // Disable speech buttons during loading

                initializeGeminiModel(); // Re-initialize model to ensure it's ready

                if (!model) { // Check if model was successfully initialized again
                    answerOutput.textContent = "無法初始化 Gemini 模型。請檢查您的 API 金鑰是否有效。";
                    qaLoading.style.display = 'none';
                    updateSpeechButtons(false, false); // Disable speech buttons on model init error
                    return;
                }

                try {
                    let base64Image;
                    let mimeType;

                    if (currentImageForQA.isLocalFile) {
                        base64Image = await fileToBase64(currentImageForQA.source);
                        mimeType = currentImageForQA.source.type;
                    } else {
                        base64Image = await urlToBase64(currentImageForQA.source);
                        mimeType = currentImageForQA.source.endsWith('.png') ? 'image/png' : currentImageForQA.source.endsWith('.gif') ? 'image/gif' : 'image/jpeg';
                    }

                    const prompt = `針對這張圖片，回答以下問題：「${questionText}」。請用大約100字以內簡潔地回答。如果圖片無法識別或問題與圖片無關，請回應「無法針對此圖片回答此問題。」`;

                    const result = await model.generateContent([
                        { text: prompt },
                        {
                            inlineData: {
                                mimeType: mimeType,
                                data: base64Image
                            }
                        }
                    ]);

                    const response = await result.response;
                    let text = response.text();

                    const safetyRatings = response.promptFeedback?.safetyRatings || [];
                    const blockedReason = response.promptFeedback?.blockReason;

                    if (blockedReason) {
                        text = `內容被阻止。原因: ${blockedReason}。部分內容可能觸發了以下安全設定:\n${safetyRatings.map(rating => `${rating.category}: ${rating.probability}`).join('\n')}`;} else if (text.trim() === '') {
                        text = "無法針對此圖片回答此問題，請稍後再試。";
                    }

                    answerOutput.textContent = text;
                    updateSpeechButtons(true, false); // Enable play button after content is loaded

                } catch (error) {
                    console.error("回答問題時出錯:", error);
                    answerOutput.textContent = "抱歉，回答問題時發生錯誤。請檢查您的 API 金鑰是否有效，或稍後再試。";
                    updateSpeechButtons(false, false); // Disable speech buttons on error
                } finally {
                    qaLoading.style.display = 'none'; // Hide QA loading indicator
                }
            });

            // Function to display instructions in a modal
            function displayInstructionsModal() {
                storyModal.classList.add('active');
                isModalOpen = true;
                clearInterval(autoPlayInterval); // Pause carousel
                isCarouselRunning = false;

                // Hide interactive features for instructions
                setInteractiveFeaturesVisibility(false);
                modalLoadingStory.style.display = 'none';
                qaLoading.style.display = 'none';
                answerOutput.textContent = '';
                questionInput.value = '';
                showTab('story'); // Always show story tab for instructions

                modalMainTitle.textContent = "操作說明";
                modalStoryTitle.textContent = ""; // No specific title for instructions

                // Filter out the Pexels and Pixabay API key sections
                let filteredInstructions = fullInstructionsMarkdown.replace(pexelsSectionToRemove, '');
                filteredInstructions = filteredInstructions.replace(pixabaySectionToRemove, '');


                // Use marked.js to parse markdown and set as innerHTML
                modalStoryContent.innerHTML = marked.parse(filteredInstructions); 
                updateSpeechButtons(true, false); // Enable play button for instructions
            }
            
            // Initialize gallery with a small delay to ensure DOM is fully ready
            setTimeout(() => {
                initGallery();
            }, 100); // 100ms delay should be sufficient
        });
    </script>
</body>
</html>
